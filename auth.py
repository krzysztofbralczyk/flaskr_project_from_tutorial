from flask import Blueprint  # flask's Blueprint class that is used to
# group similar code or views(routes)(modularity)

from flask import request  # flask's object representing http request itself

# it allows for example checking which request method was used or what was
# POST'ed in form

bp = Blueprint('auth', __name__, url_prefix='/auth')  # create a Blueprint
# that is named auth, takes __name__ argument(as always), and adds /auth
# to every route created in this Blueprint. this bluprint will be
# added to app factory using app.register_blueprint(auth.bp)

from flaskr.db import get_db  # our self made function returning connection to
# sqlite databases

from werkzeug.security import generate_password_hash  # function used to
# tore passwords in database as hashes, not in plain text

from flask import redirect, url_for  # redirect makes you go to different
# url while not changing url that is written in browser window
# url_for gives you route for the the view(route function) you give it

from flask import render_template  # makes it possible to return html site

from flask import flash  # stores message from backend and make it possible to


# render it in HTML using templating engine (Jinja2)

@bp.route('/register', methods=['GET', 'POST'])  # auth/register url accept methods
# get and post. post is correct, secure solution so we handle it, get makes us
# reload the registration page
def register():  # view function register

    if request.method == 'POST':
        username = request.form['username']  # get value from form filled be user
        # with id/name (not sure which one it was) username and assign for later

        password = request.form['password']
        db = get_db()  # create connection to database

        error = None  # give error variable default value

        if not username:  # set error depending on what user filled in form
            error = "Username is required"
        elif not password:
            error = "Password is required"
        elif db.execute(  # direct sql query using sqlite3 methods
                'SELECT id FROM user WHERE username = ?', (username,)
        ).fetchone() is not None:
            error = "User {} is already registered".format(username)

        if error is None:  # when no error, insert new user into database
            db.execute(
                'INSERT INTO user (username, password) VALUES (?, ?)',
                (username, generate_password_hash(password))  # password stored as hash
            )
            db.commit()  # if data is modified, not read only, we need to commit changes

            return redirect(url_for('auth.login'))  # if registration succesfull,
            # redirect to url responsible for login view function. 'auth.' before
            # login is necessary because this view function is part of blueprint

        flash(error)  # stores message to be rendered in html

    return render_template('auth/register.html')  # gets returned if registration went


# wrong (any of 3 errors happened)

from werkzeug.security import check_password_hash  # function comparing if
# password and password hash generated by generate_password_hash are the same

from flask import session  # default session in flask is cookie based. It is


# secured only to make sure it can't be tampered without secret key, but it's still
# not as secure as server-based session. No passwords or important info should
# be stored in this kind of session and it has all limitations of cookies like
# max size of 4 kb. Also session object is/can be treated as dictionary.

@bp.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        db = get_db()
        error = None
        user = db.execute(  # execute select query
            'SELECT * FROM user WHERE username = ?', (username,)
        ).fetchone()  # get one(first)(only) result and assing int to user
        # variable. Normally it would be a tuple but database connection is set
        # to return dictionary-like-behaving object where keys are column names

        if user is None:
            error = "Incorrect username"
        elif not check_password_hash(user['password'], password):
            error = "Incorrect password"

        if error is None:
            session.clear()  # clear session dictionary
            session['user_id'] = user['id']  # remember current user id (from db)
            # in session dictionary, so it's available for next requests
            return redirect(url_for('index'))

        flash(error)  # if error happened, it will be flashed. interesting fact:
        # flash object is saved in session so if you clear session before flashing
        # message, it will be goneeee

    return render_template('auth/login.html')  # if error happened, we will get
    # this html returned. folder auth will be a folder in templates


from flask import g  # object used to share information between different


# functions during single requests

@bp.before_app_request  # before_request but for blueprint. decorates
# function that will be executed before every request
def load_logged_in_user():
    user_id = session.get('user_id')  # is session['user_id'] nor possible?

    if user_id is None:
        g.user = None
    else:
        g.user = get_db().execute(
            'SELECT * FROM user WHERE id = ?', (user_id,)
        ).fetchone()


@bp.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('index'))


import functools  # library for higher order functions, in this case, for decorator


def login_required(view):
    @functools.wraps(view)  # maked decorated function have the same name
    # as original one. Without it, decorator would change it's name to name
    # of a wrapper
    def wrapped_view(**kwargs):  # take any number of keyword arguments and store
        # in dictionary
        if g.user is None:  # if load_logged_in_user executed before every
            # request wasn't able to find 'user_id' in session
            return redirect(url_for(auth.login))  # redirect to url for view
            # function in auth blueprint called login (auth.login)
        return view(**kwargs)

    return wrapped_view
